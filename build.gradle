
import com.sun.org.apache.bcel.internal.util.ClassPath;
apply plugin: 'java'
apply plugin: 'eclipse'
apply plugin: 'war'

sourceCompatibility=1.5
targetCompatibility=1.5

ext.springVersion = '3.1.3.RELEASE'
ext.springDataVersion = '1.2.0.RELEASE'
ext.querydslVersion = '2.9.0'
ext.hibernateVersion = '4.1.8.Final'
ext.junitVersion = '4.11'
ext.jodaTimeVersion = '2.1'
ext.apacheCommonsCodecVersion = '1.7'
ext.log4jVersion = '1.2.17'
ext.springSocialVersion = '1.0.2.RELEASE' 
ext.dbmaintainVersion = '2.4'
ext.aspectjVersion = '1.6.12'

sourceSets.main.java.srcDir 'src/querydsl/java'

repositories{
	maven{
		url "https://www.laertessoft.biz/artifactory/repo"
	}
}

dependencies{
	compile ("junit:junit:${junitVersion}")
	compile ("org.springframework.security:spring-security-web:${springVersion}")
	compile ("org.springframework:spring-context:${springVersion}")
	compile ("joda-time:joda-time:${jodaTimeVersion}")
	compile ("org.springframework.data:spring-data-jpa:${springDataVersion}")
	compile ("com.mysema.querydsl:querydsl-jpa:${querydslVersion}")
	compile ("com.mysema.querydsl:querydsl-apt:${querydslVersion}")
	compile ("org.hibernate:hibernate-entitymanager:${hibernateVersion}")
	compile ("commons-codec:commons-codec:${apacheCommonsCodecVersion}")
	compile ("log4j:log4j:${log4jVersion}")
	compile ("org.springframework.social:spring-social-web:${springSocialVersion}")
	compile ("org.springframework.social:spring-social-facebook:${springSocialVersion}")
	compile ("org.springframework.social:spring-social-twitter:${springSocialVersion}")
	providedCompile ("javax.servlet:servlet-api:2.5")
	providedCompile ("javax.servlet.jsp:jsp-api:2.1")
	compile ("javax.servlet:jstl:1.2")
	compile ("org.hibernate:hibernate-validator-annotation-processor:4.3.0.Final")
	compile ("org.hibernate:hibernate-validator:4.3.0.Final")
	compile ("org.javassist:javassist:3.15.0-GA")
	compile ("commons-lang:commons-lang:1.0")
	compile ("commons-collections:commons-collections:3.2.1")
	compile ("org.springframework.webflow:spring-webflow:2.3.0.RELEASE")
	compile ("javax.validation:validation-api:1.0.0.GA")
	compile ("org.dbmaintain:dbmaintain:${dbmaintainVersion}")
	compile ("org.springframework:spring-test:${springVersion}")
	runtime ("org.springframework.security:spring-security-config:${springVersion}")
	runtime ("commons-dbcp:commons-dbcp:1.4")
	runtime ("mysql:mysql-connector-java:5.1.18")
	runtime ("org.aspectj:aspectjweaver:${aspectjVersion}")
	compile ("org.drools:drools-core:5.4.0.Final")
	compile ("org.drools:drools-compiler:5.4.0.Final")
}

configureEnv()

def configureEnv(){
	ext.environment = hasProperty('teamcity')?'ci':hasProperty('environment')?environment:'local'
	println "Building environment: $environment"
	def config = new ConfigSlurper().parse(file('env/'+environment+'.gradle').toURI().toURL())
	ext.config = config	
}

task generateQueryDSL (type: JavaCompile) {
		source = 'src/main/java'
		classpath = configurations.compile
		options.compilerArgs = [
			"-proc:only",
			"-processor", "com.mysema.query.apt.hibernate.HibernateAnnotationProcessor"
		]
		destinationDir = file('src/querydsl/java')
}

task updateDatabase{
	ant.taskdef(resource: "dbmaintain-anttasks.xml", classpath: configurations.runtime.asPath)
	ant.projectDir = projectDir
	ant.updateDatabase(scriptLocations: '${projectDir}/src/main/dbscripts', autoCreateDbMaintainScriptsTable: true, qualifiers: 'scripts', fromScratchEnabled: true){
		database(driverClassName: config.openserv.db.driver, 
				url: config.openserv.db.url, 
				userName: config.openserv.db.username, 
				password: config.openserv.db.password,
				schemaNames: config.openserv.db.schemas)	
	}
}

task packageScripts{
	ant.taskdef(resource: "dbmaintain-anttasks.xml", classpath: configurations.runtime.asPath)
	ant.projectDir = projectDir
	ant.createScriptArchive(scriptLocations: '${projectDir}/src/main/dbscripts', 
							qualifiers: 'scripts', 
							archiveFileName: "openserv-scripts.zip")
}

compileJava.dependsOn generateQueryDSL
test.dependsOn updateDatabase
assemble.dependsOn packageScripts

task wrapper(type: Wrapper){
	gradleVersion = '1.3'
}

/**
 * Adds a task that reports which dependencies have newer versions.
 * <p>
 * The <tt>revision</tt> project property controls the resolution strategy:
 * <ul>
 *   <li>release: selects the latest release
 *   <li>milestone: select the latest version being either a milestone or a release (default)
 *   <li>integration: selects the latest revision of the dependency module (such as SNAPSHOT)
 * </ul>
 */
import org.gradle.api.internal.artifacts.version.LatestVersionSemanticComparator
task dependencyUpdates(description: "Displays the dependency updates for the project.",
    group: "Help") << {
  def current = getProjectAndBuildscriptDependencies()
  def (resolved, unresolved) = resolveLatestDepedencies(current)
  def (currentVersions, latestVersions, sameVersions, downgradeVersions, upgradeVersions) =
    getVersionMapping(current, resolved)
  displayReport(currentVersions, latestVersions, sameVersions,
    downgradeVersions, upgradeVersions, unresolved)
}
/** Returns {@link ExternalDependency} collected from the project and buildscript. */
def getProjectAndBuildscriptDependencies() {
  allprojects.collectMany{ project ->
    (project.configurations + project.buildscript.configurations).collectMany { it.allDependencies }
  }.findAll { it instanceof ExternalDependency }
}
/**
 * Returns {@link ResolvedDependency} and {@link UnresolvedDependency} collected after evaluating
 * the latest dependencies to determine the newest versions.
 */
def resolveLatestDepedencies(current) {
  if (current.empty) {
    return [[], []]
  }
  def unresolved = current.collect { dependency ->
    dependencies.create(group: dependency.group, name: dependency.name, 
        version: "latest.${revisionLevel()}") {
      transitive = false
    }
  }
  def lenient = configurations.detachedConfiguration(unresolved as Dependency[])
    .resolvedConfiguration.lenientConfiguration
  [lenient.firstLevelModuleDependencies, lenient.unresolvedModuleDependencies]
}
/** Organizes the dependencies into version mappings. */
def getVersionMapping(current, resolved) {
  def currentVersions = current.collectEntries { dependency ->
     [label(dependency), dependency.version]
  }
  def latestVersions = resolved.collectEntries { dependency ->
     ["${dependency.moduleGroup}:${dependency.moduleName}".toString(), dependency.moduleVersion]
  }
  def sameVersions = currentVersions.intersect(latestVersions)
  def comparator = new LatestVersionSemanticComparator()
  def upgradeVersions = latestVersions.findAll { label, version ->
    comparator.compare(version, currentVersions[label]) > 0
  }
  def downgradeVersions = latestVersions.findAll { label, version ->
    comparator.compare(version, currentVersions[label]) < 0
  }
  [currentVersions, latestVersions, sameVersions, downgradeVersions, upgradeVersions]
}
/** Returns the dependency's group and name. */
def label(dependency) { "${dependency.group}:${dependency.name}".toString() }
/** Returns the resolution revision level. */
def revisionLevel() { project.properties.get("revision", "milestone") }
/* ---------------- Display Report -------------- */
/** Prints the report to the console. */
def displayReport(currentVersions, latestVersions, sameVersions,
    downgradeVersions, upgradeVersions, unresolved) {
  displayHeader()
  displayUpToDate(sameVersions)
  displayExceedLatestFound(currentVersions, downgradeVersions)
  displayUpgrades(currentVersions, upgradeVersions)
  displayUnresolved(unresolved)
}
def displayHeader() {
  println """
    |------------------------------------------------------------
    |${project.path} Project Dependency Updates
    |------------------------------------------------------------""".stripMargin()
}
def displayUpToDate(sameVersions) {
  if (sameVersions.isEmpty()) {
    println "\nAll dependencies have newer versions."
  } else {
    println "\nThe following dependencies are using the newest ${revisionLevel()} version:"
    sameVersions.sort().each { println " - ${it.key}:${it.value}" }
  }
}
def displayExceedLatestFound(currentVersions, downgradeVersions) {
  if (!downgradeVersions.isEmpty()) {
    println("\nThe following dependencies exceed the version found at the "
      + revisionLevel() + " revision level:")
    downgradeVersions.sort().each { label, version ->
      def currentVersion = currentVersions[label]
      println " - ${label} [${currentVersion} <- ${version}]"
    }
  }
}
def displayUpgrades(currentVersions, upgradeVersions) {
  if (upgradeVersions.isEmpty()) {
    println "\nAll dependencies are using the latest ${revisionLevel()} versions."
  } else {
    println("\nThe following dependencies have newer ${revisionLevel()} versions:")
    upgradeVersions.sort().each { label, version ->
      def currentVersion = currentVersions[label]
      println " - ${label} [${currentVersion} -> ${version}]"
    }
  }
}
def displayUnresolved(unresolved) {
  if (!unresolved.isEmpty()) {
    println("\nFailed to determine the latest version for the following dependencies:")
    unresolved.sort { a, b -> label(a.selector) <=> label(b.selector) }.each {
      println " - " + label(it.selector)
      logger.info "The exception that is the cause of unresolved state:", it.problem
    }
  }
}

